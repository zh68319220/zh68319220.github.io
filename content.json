{"meta":{"title":"YF's Blog","subtitle":null,"description":null,"author":"YuFeng Zhang","url":"http://yfzhang.cn"},"pages":[{"title":"categories","date":"2016-06-01T08:04:48.000Z","updated":"2016-09-27T05:55:18.828Z","comments":false,"path":"categories/index.html","permalink":"http://yfzhang.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-06-01T08:09:10.000Z","updated":"2016-09-27T05:55:18.829Z","comments":false,"path":"tags/index.html","permalink":"http://yfzhang.cn/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2016-06-01T08:13:44.000Z","updated":"2016-09-27T05:55:18.826Z","comments":true,"path":"about/index.html","permalink":"http://yfzhang.cn/about/index.html","excerpt":"","text":""}],"posts":[{"title":"如何理解javascript中的call和apply","slug":"call-apply","date":"2016-10-10T06:03:15.000Z","updated":"2016-10-11T10:04:48.237Z","comments":true,"path":"2016/10/10/call-apply/","link":"","permalink":"http://yfzhang.cn/2016/10/10/call-apply/","excerpt":"","text":"1234567891011&lt;input type=\"text\" id=\"myText\" value=\"input text\"&gt;&lt;script&gt; function Obj()&#123;this.value=\"对象\";&#125; var value=\"global 变量\"; function Fun1()&#123;alert(this.value);&#125; window.Fun1(); //global 变量 Fun1.call(window); //global 变量 Fun1.call(document.getElementById('myText')); //input text Fun1.call(new Obj()); //对象&lt;/script&gt; this指向了call方法的第一个参数，分别是window、input text、对象 所以当运行下面代码的时候第一个alert出来的值是func而不是myfunc，因为this取决于call的第一个参数：1234567var func=new function()&#123;this.a=\"func\"&#125;var myfunc=function(x)&#123; var a=\"myfunc\"; alert(this.a); alert(x);&#125;myfunc.call(func,\"var\"); apply 与 call 的区别在于 apply的第二个参数必须传入一个数组，并把这个数组中的n个元素当作n的参数使用，然而call即使传入了一个数组，也只会当成一个参数处理。所以call(obj, arg1, arg2) 与 apply(obj, [arg1, arg2]) 的作用一样。 由于它们的特性，用来做 继承 就很合适。两个类：123456789101112131415161718192021function Person(name,age) &#123; var sex = 0; this.name = name; this.age = age;&#125;Person.prototype.say = function() &#123; console.log(\"person say\");&#125;function Student(name,age,height) &#123; Person.apply(this,arguments); //Person.call(this,name,age,height); //call方法的传参方式; console.log(this.sex); this.height = height;&#125;var student = new Student(\"chams\",22,\"173\");console.log(\"name:\" + student.name + \" age:\" + student.age + \" height:\" + student.height);console.log(student.say); 可见Student类的构造方法中利用call和apply继承了Person中的成员变量和方法，但是 Person类中的私有成员变量sex和原型上的say方法却没有被继承 经过改进后可变为： 12345678910111213141516171819202122function Person(name,age) &#123; var sex = 0; this.name = name; this.age = age;&#125;Person.prototype.say = function() &#123; console.log(\"person say\");&#125;function Student(name,age,height) &#123; Person.apply(this,arguments); //Person.call(this,name,age,height); //call方法的传参方式; this.height = height;&#125;Student.prototype = Person.prototype;var student = new Student(\"chams\",22,\"173\");Student.prototype.a = 1;console.log(Person.prototype.a); 现在父类的成员变量和其原型上的变量都继承过来了，但是当我 改变子类原型的变量时，同样会影响到父类，这违背了继承的规则，也会影响到父类 。 解决方法是加入一个中间变量类: 123456789101112131415161718192021222324function Person(name,age) &#123; var sex = 0; this.name = name; this.age = age;&#125;Person.prototype.say = function() &#123; console.log(\"person say\");&#125;function Student(name,age,height) &#123; Person.apply(this,arguments); //Person.call(this,name,age,height); //call方法的传参方式; this.height = height;&#125;var F = new Function()&#123;&#125;F.prototype = Person.prototype;Student.prototype = new F();var student = new Student(\"chams\",22,\"173\");Student.prototype.a = 1;console.log(Person.prototype.a);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yfzhang.cn/tags/编程/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}]},{"title":"如何使用javascript创造一个类库","slug":"create-a-js-library","date":"2016-10-09T09:05:36.000Z","updated":"2016-10-11T08:36:59.585Z","comments":true,"path":"2016/10/09/create-a-js-library/","link":"","permalink":"http://yfzhang.cn/2016/10/09/create-a-js-library/","excerpt":"","text":"以jQuery为例：1234567891011121314151617181920212223242526272829303132333435363738394041( function( global, factory ) &#123; \"use strict\"; if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // For CommonJS and CommonJS-like environments where a proper `window` // is present, execute the factory and get jQuery. // For environments that do not have a `window` with a `document` // (such as Node.js), expose a factory as module.exports. // This accentuates the need for the creation of a real `window`. // e.g. var jQuery = require(\"jquery\")(window); // See ticket #14549 for more info. module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) &#123;// Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common// enough that all such attempts are guarded in a try block.\"use strict\";var jQuery = function()&#123; // jQuery func&#125;;window.jQuery = jQuery;return jQuery;&#125; ); 立即执行函数避免了全局环境的污染，像函数传入2个参数分别是global和factory，对应了typeof window !== “undefined” ? window : this 和 function( window, noGlobal){ … return jQuery; }这两个参数。 window传入之前会检查其是否存在，之后兼容AMD/CMD两种导入方式。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yfzhang.cn/tags/编程/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}]},{"title":"使用createjs完成一次H5开发","slug":"createjs-practice","date":"2016-09-27T07:59:58.000Z","updated":"2016-09-28T01:55:14.496Z","comments":true,"path":"2016/09/27/createjs-practice/","link":"","permalink":"http://yfzhang.cn/2016/09/27/createjs-practice/","excerpt":"","text":"预加载1234567891011121314151617var preload = new createjs.LoadQueue(false);preload.addEventListener(\"fileload\", handleFileComplete);preload.loadManifest([ &#123; \"id\": \"img1\", \"src\": \"img1url\" &#125;, &#123; \"id\": \"img2\", \"src\": \"img2url\" &#125;, &#123; \"id\": \"img3\", \"src\": \"img3url\" &#125;]);function handleFileComplete() &#123; if(preload._numItems == preload._numItemsLoaded)&#123; // 隐藏加载层 $('.loading').hide(); // 初始化舞台 main = new stageUtil(); &#125;else&#123; // 处理全部未加载成功 &#125;&#125; 制作SpriteSheet首先下载TexturePacker的破解版，把切好的图统一放在一个文件夹下，并选择easelJs的方式导出json和png文件： 使用TexturePacker为我们生成的json文件(data)和png文件(1.png)来加入舞台之中：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=\"main\"&gt;&lt;canvas id=\"cvs\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"create.min.js的路径\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var preload = new createjs.LoadQueue(false), canvas = document.getElementById('cvs'), stage = new createjs.Stage('cvs'); createjs.Touch.enable(stage); createjs.Ticker.framerate = 60; createjs.Ticker.on(\"tick\", stage); preload.addEventListener(\"fileload\", handleFileComplete); preload.loadManifest([ &#123; \"id\": \"img1\", \"src\": \"1.png\" &#125; ]); function handleFileComplete() &#123; if(preload._numItems == preload._numItemsLoaded)&#123; var data = &#123; \"images\": [\"1.png\"], \"frames\": [ [2, 1380, 1091, 573], [2, 695, 1165, 683], [2, 2, 1176, 691] ], \"animations\": &#123; \"1b\":[0], \"3707_a7098e26_e5ea_06ad_e6dd_49c956d23071_1\":[1], \"mxg2\":[2] &#125; &#125;; drawSprite(0, 0, data, \"mxg2\", 0.1, 5); drawSprite(0, 0, data, \"3707_a7098e26_e5ea_06ad_e6dd_49c956d23071_1\", 0.1, 5); drawSprite(0, 0, data, \"1b\", 0.1, 5); &#125; &#125;; function drawSprite(x, y, data, name, scale, rate) &#123; var spriteSheet = new createjs.SpriteSheet(data); var animation = new createjs.Sprite(spriteSheet, name); animation.x = x; animation.y = y; animation.scaleY = animation.scaleX = scale; animation.framerate = rate; var child = stage.addChild(animation); stage.setChildIndex(child, 999); &#125;;&lt;/script&gt; 由于图片资源已经预加载，所以重复drawSprite方法画出的图片的z-index关系完全取决于调用的先后顺序： “1b”在最上层， “3707_a7098e26_e5ea_06ad_e6dd_49c956d23071_1” 在中间，”mxg2”在最下层： 几种createJs动画的实现方式1.SpriteSheet修改由TexturePacker生成的json数据中的”animations”属性，如：12345678910111213&#123; \"images\": [\"1.png\"], \"frames\": [ [2, 1380, 1091, 573], [2, 695, 1165, 683], [2, 2, 1176, 691] ], \"animations\": &#123; \"a1\":[0, 1], \"a2\":[1, 2], \"a3\":[2] &#125;&#125; “frames”数组的length代表了TexturePacker合成了多少张单图，而”animations”就配置了你需要组合动画的3种方式：a1,a2,a3。 2.TweenJscreateJs 细分为easelJs(基本库)、tweenJs(补间动画库)、preloadJs(预加载库)、soundJs(音频库)。各个库的使用方式官方都有详细介绍，tweenJs的用法例如：1createjs.Tween.get(child,&#123;loop:true&#125;).to(&#123;skewY: 720, alpha: 1&#125;, 1000).wait(1000); 3.container将动画资源加入container之中，通过container的动画来实现一些整体的动画效果。可避免重复对各个资源加动画：12345678910111213141516171819202122232425262728293031// 斜轮播var contianer = new createjs.Container();contianer.x = 300;contianer.y = 300;contianer.regX = 230;contianer.regY = 400;contianer.rotation = 30;for (var i = 0; i &lt;= 6; i++) &#123; if( (i+1)%2 == 1 )&#123; _this.drawBitmap(\"http://xx.png\", -300, (150*i + 50), 1, \"1\", function(child) &#123; contianer.addChild(child); createjs.Tween.get(child,&#123;loop:false&#125;).to(&#123; x: -60&#125;, 600).call(cn1); function cn1() &#123; child.x = -300; createjs.Tween.get(child,&#123;loop:false&#125;).to(&#123; x: -60&#125;, 600).call(cn1); &#125; &#125;); &#125; else&#123; _this.drawBitmap(\"http://xx2.png\", -60, (150*i + 50), 1, \"1\", function(child) &#123; contianer.addChild(child); createjs.Tween.get(child,&#123;loop:false&#125;).to(&#123; x: -300&#125;, 600).call(cn1); function cn1() &#123; child.x = -60; createjs.Tween.get(child,&#123;loop:false&#125;).to(&#123; x: -300&#125;, 600).call(cn1); &#125; &#125;); &#125;&#125;_this.stage.addChild(contianer);_this.stage.setChildIndex(contianer, 1); 点击域1234567891011// 画点击域stageUtil.prototype.drawHitarea = function(event, conf, fn)&#123; var _this = this; var hit = new createjs.Shape(new createjs.Graphics().f(\"rgba(0,0,0,0.01)\").r(conf.x,conf.y,conf.w,conf.h)); _this.stage.addChild(hit); _this.stage.setChildIndex(hit, 99); _this.stage.update(); hit.addEventListener(event, function(e) &#123; fn(e); &#125;, false);&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yfzhang.cn/tags/编程/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}]},{"title":"分析jQuery源码","slug":"jquery-source","date":"2016-09-27T06:18:19.000Z","updated":"2016-09-27T09:10:23.409Z","comments":true,"path":"2016/09/27/jquery-source/","link":"","permalink":"http://yfzhang.cn/2016/09/27/jquery-source/","excerpt":"","text":"jq由grunt这个构建工具构建，我们可以通过package.json文件查看构建jquery需要使用到的一些modules。还可以通过查看Gruntfile.js了解jquery这个项目的具体构建方案和调试方案。但这个不是重点。我们下面来看看项目中src下的core.js关于jQuery变量的定义：1234567// Define a local copy of jQueryjQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context );&#125; 这里jQuery这个方法 new了jq原型上的init这个类并传入selector和context两个参数。init这个类的定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111init = jQuery.fn.init = function( selector, context, root ) &#123; var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false) if ( !selector ) &#123; return this; &#125; // Method init() accepts an alternate rootjQuery // so migrate can support jQuery.sub (gh-2101) root = root || rootjQuery; // Handle HTML strings if ( typeof selector === \"string\" ) &#123; if ( selector[ 0 ] === \"&lt;\" &amp;&amp; selector[ selector.length - 1 ] === \"&gt;\" &amp;&amp; selector.length &gt;= 3 ) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; &#125; else &#123; match = rquickExpr.exec( selector ); &#125; // Match html or make sure no context is specified for #id if ( match &amp;&amp; ( match[ 1 ] || !context ) ) &#123; // HANDLE: $(html) -&gt; $(array) if ( match[ 1 ] ) &#123; context = context instanceof jQuery ? context[ 0 ] : context; // Option to run scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge( this, jQuery.parseHTML( match[ 1 ], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true ) ); // HANDLE: $(html, props) if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; for ( match in context ) &#123; // Properties of context are called as methods if possible if ( jQuery.isFunction( this[ match ] ) ) &#123; this[ match ]( context[ match ] ); // ...and otherwise set as attributes &#125; else &#123; this.attr( match, context[ match ] ); &#125; &#125; &#125; return this; // HANDLE: $(#id) &#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this; &#125; // HANDLE: $(expr, $(...)) &#125; else if ( !context || context.jquery ) &#123; return ( context || root ).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) &#125; else &#123; return this.constructor( context ).find( selector ); &#125; // HANDLE: $(DOMElement) &#125; else if ( selector.nodeType ) &#123; this[ 0 ] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready &#125; else if ( jQuery.isFunction( selector ) ) &#123; return root.ready !== undefined ? root.ready( selector ) : // Execute immediately if ready is not present selector( jQuery ); &#125; return jQuery.makeArray( selector, this );&#125;;// Give the init function the jQuery prototype for later instantiationinit.prototype = jQuery.fn;define( [ // required things], function( jQuery ) &#123;\"use strict\";return ( window.jQuery = window.$ = jQuery );&#125; ); 此方法主要通过select、context、root这三个参数来查找用户想找到的DOM元素，并把它或它们放入0这个属性之中。例如$(“#jq”)则会对应到代码之中的：123456789101112// HANDLE: $(#id)&#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this;&#125; 来处理，命中其他条件，则对应其他的处理方式，源码中都有相应注释。 重点是最后一句:init.prototype = jQuery.fn;，init这个类的原型赋值成了jQuery这个类的原型，那么现在init也将拥有jQuery原型上的方法和属性。最后将window上的jQuery和$赋值成jQuery这个变量。 当我们调用$(arguments)去匹配某一个或多个DOM时， 实际上jq创建给我们一个init类的对象，并执行了init这个构造方法并根据参数返回了包含所匹配的DOM的一个init对象，这个init类的原型本身又是jQuery这个类的原型，当我们拥有init这个类的对象的时候，同时也可以访问jQuery原型链上的方法和属性了。 那当我们调用$(arguments).attr(argument) 的时候，这个attr方法是在哪里定义的呢？我们从上述分析之中可以知道 $(arguments) 实际上是返回了一个init对象，而这个对象是可以访问jQuery这个类的原型链上的属性和方法的。jQuery则使用了extend 和 fn.extend来分别拓展 jq的公共方法和jq的原型上的方法(供$(arguments)返回的对象来调用)。extend方法源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 这里jQuery.extend 和 jQuery.fn.extend都赋值成了相同的方法，在调用 $.extend(argument) 和 $.extend(argument) 的时候，方法内this指向是不同的，前者会直接指向jQuery这个类，后者却执行jQuery.fn(即jQuery.prototype)。 而这个方法，简单的理解就是遍历传入的对象的属性名name,属性值value，并赋值this[name] = value， 这里的value往往是个方法。 所以当我们事先定义$.extend({a: 1}); 内部实际上执行了$[a] = 1 而已。当我们访问$的‘a’这个属性时，会返回1这个值。所以我们在使用jQuery的时候也经常会用extend这个方式来预先定义一些处理方法，以供之后的使用。 以上则是jQuery这个框架的主要设计方法，当然jQuery的一些具体的DOM处理方式也是值得我们去探索和学习的。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yfzhang.cn/tags/编程/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}]},{"title":"使用font-spider在H5中嵌入自定义字体","slug":"font-spider","date":"2016-06-08T09:41:58.000Z","updated":"2016-09-27T05:55:18.822Z","comments":true,"path":"2016/06/08/font-spider/","link":"","permalink":"http://yfzhang.cn/2016/06/08/font-spider/","excerpt":"","text":"设计往往会提供一些自定义字体，而调用自定义字体往往会增加这种单页页面的负担，但是我们为了尽量还原设计图，可以考虑将压缩之后的字体文件嵌入的网页之中。 1.全局安装font-spider插件1$ npm install -g font-spider 2.在你需要加入字体的HTML页面上加入下列CSS12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*声明 WebFont*/ @font-face &#123; font-family: 'ouzhou'; src: url('./ouzhou.eot'); src: url('./ouzhou.eot?#font-spider') format('embedded-opentype'), url('./ouzhou.woff') format('woff'), url('./ouzhou.ttf') format('truetype'), url('./ouzhou.svg') format('svg'); font-weight: normal; font-style: normal; &#125; body&#123; font-family: 'ouzhou'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;123456789.:法国英国美国德国&lt;/body&gt;&lt;/html&gt; 其中的.ttf文件是必须存在的,body标签中的文字是font-spider用来转化的字体,未在body中出现的字符将会用浏览器默认的字体显示。 3.执行font-spider的指令1font-spider ./index.html(html的路径) 这时font-spider会在目录下生成： 浏览器上查看，字体文件成功应用: demo中使用自定义字体的字符仅有“123456789.:法国英国美国德国”这几个，所以字体文件都在5KB左右的大小。比较麻烦的是需要将H5中会使用到的字体都收集过来让font-spider解析并生成字体文件。","categories":[{"name":"css","slug":"css","permalink":"http://yfzhang.cn/categories/css/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yfzhang.cn/tags/CSS3/"}],"keywords":[{"name":"css","slug":"css","permalink":"http://yfzhang.cn/categories/css/"}]},{"title":"First Blood.","slug":"hello-world","date":"2016-06-01T09:41:58.000Z","updated":"2016-09-27T05:55:18.825Z","comments":true,"path":"2016/06/01/hello-world/","link":"","permalink":"http://yfzhang.cn/2016/06/01/hello-world/","excerpt":"","text":"之前在主机公园上使用免费的虚拟主机搭建了一个博客,由于速度太慢(服务器貌似在印度…)果断入坑hexo. 下面记录一下更新博文和重新部署的方式: Quick Start1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"web","slug":"web","permalink":"http://yfzhang.cn/categories/web/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://yfzhang.cn/tags/建站/"}],"keywords":[{"name":"web","slug":"web","permalink":"http://yfzhang.cn/categories/web/"}]}]}