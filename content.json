{"meta":{"title":"YF's Blog","subtitle":null,"description":null,"author":"YuFeng Zhang","url":"http://yfzhang.cn"},"pages":[{"title":"tags","date":"2016-06-01T08:09:10.000Z","updated":"2016-09-27T05:55:18.829Z","comments":false,"path":"tags/index.html","permalink":"http://yfzhang.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-06-01T08:04:48.000Z","updated":"2016-09-27T05:55:18.828Z","comments":false,"path":"categories/index.html","permalink":"http://yfzhang.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2016-06-01T08:13:44.000Z","updated":"2016-09-27T05:55:18.826Z","comments":true,"path":"about/index.html","permalink":"http://yfzhang.cn/about/index.html","excerpt":"","text":""}],"posts":[{"title":"解读jquery源码","slug":"jquery-source","date":"2016-09-27T06:18:19.000Z","updated":"2016-09-27T07:31:06.802Z","comments":true,"path":"2016/09/27/jquery-source/","link":"","permalink":"http://yfzhang.cn/2016/09/27/jquery-source/","excerpt":"","text":"jq由grunt这个构建工具构建，我们可以通过package.json文件查看构建jquery需要使用到的一些modules。还可以通过查看Gruntfile.js了解jquery这个项目的具体构建方案和调试方案。但这个不是重点。我们下面来看看项目中src下的core.js关于jQuery变量的定义：1234567// Define a local copy of jQueryjQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context );&#125; 这里jQuery这个方法 new了jq原型上的init这个类并传入selector和context两个参数。init这个类的定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111init = jQuery.fn.init = function( selector, context, root ) &#123; var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false) if ( !selector ) &#123; return this; &#125; // Method init() accepts an alternate rootjQuery // so migrate can support jQuery.sub (gh-2101) root = root || rootjQuery; // Handle HTML strings if ( typeof selector === \"string\" ) &#123; if ( selector[ 0 ] === \"&lt;\" &amp;&amp; selector[ selector.length - 1 ] === \"&gt;\" &amp;&amp; selector.length &gt;= 3 ) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; &#125; else &#123; match = rquickExpr.exec( selector ); &#125; // Match html or make sure no context is specified for #id if ( match &amp;&amp; ( match[ 1 ] || !context ) ) &#123; // HANDLE: $(html) -&gt; $(array) if ( match[ 1 ] ) &#123; context = context instanceof jQuery ? context[ 0 ] : context; // Option to run scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge( this, jQuery.parseHTML( match[ 1 ], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true ) ); // HANDLE: $(html, props) if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; for ( match in context ) &#123; // Properties of context are called as methods if possible if ( jQuery.isFunction( this[ match ] ) ) &#123; this[ match ]( context[ match ] ); // ...and otherwise set as attributes &#125; else &#123; this.attr( match, context[ match ] ); &#125; &#125; &#125; return this; // HANDLE: $(#id) &#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this; &#125; // HANDLE: $(expr, $(...)) &#125; else if ( !context || context.jquery ) &#123; return ( context || root ).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) &#125; else &#123; return this.constructor( context ).find( selector ); &#125; // HANDLE: $(DOMElement) &#125; else if ( selector.nodeType ) &#123; this[ 0 ] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready &#125; else if ( jQuery.isFunction( selector ) ) &#123; return root.ready !== undefined ? root.ready( selector ) : // Execute immediately if ready is not present selector( jQuery ); &#125; return jQuery.makeArray( selector, this );&#125;;// Give the init function the jQuery prototype for later instantiationinit.prototype = jQuery.fn;define( [ // required things], function( jQuery ) &#123;\"use strict\";return ( window.jQuery = window.$ = jQuery );&#125; ); 此方法主要通过select、context、root这三个参数来查找用户想找到的DOM元素，并把它或它们放入0这个属性之中。例如$(“#jq”)则会对应到代码之中的：123456789101112// HANDLE: $(#id)&#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this;&#125; 来处理，命中其他条件，则对应其他的处理方式，源码中都有相应注释。 重点是最后一句:init.prototype = jQuery.fn;，init这个类的原型赋值成了jQuery这个类的原型，那么现在init也将拥有jQuery原型上的方法和属性。最后将window上的jQuery和$赋值成jQuery这个变量。 当我们调用$(arguments)去匹配某一个或多个DOM时， 实际上jq创建给我们一个init类的对象，并执行了init这个构造方法并根据参数返回了包含所匹配的DOM的一个init对象，这个init类的原型本身又是jQuery这个类的原型，当我们拥有init这个类的对象的时候，同时也可以访问jQuery原型链上的方法和属性了。 那当我们调用$(arguments).attr(argument) 的时候，这个attr方法是在哪里定义的呢？我们从上述分析之中可以知道 $(arguments) 实际上是返回了一个init对象，而这个对象是可以访问jQuery这个类的原型链上的属性和方法的。jQuery则使用了extend 和 fn.extend来分别拓展 jq的公共方法和jq的原型上的方法(供$(arguments)返回的对象来调用)。extend方法源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 这里jQuery.extend 和 jQuery.fn.extend都赋值成了相同的方法，在调用 $.extend(argument) 和 $.extend(argument) 的时候，方法内this指向是不同的，前者会直接指向jQuery这个类，后者却执行jQuery.fn(即jQuery.prototype)。 而这个方法，简单的理解就是遍历传入的对象的属性名name,属性值value，并赋值this[name] = value， 这里的value往往是个方法。 所以当我们事先定义$.extend({a: 1}); 内部实际上执行了$[a] = 1 而已。当我们访问$的‘a’这个属性时，会返回1这个值。所以我们在使用jQuery的时候也经常会用extend这个方式来预先定义一些处理方法，以供之后的使用。 以上则是jQuery这个框架的主要设计方法，当然jQuery的一些具体的DOM处理方式也是值得我们去探索和学习的。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yfzhang.cn/tags/编程/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://yfzhang.cn/categories/javascript/"}]},{"title":"使用font-spider在H5中嵌入自定义字体","slug":"font-spider","date":"2016-06-08T09:41:58.000Z","updated":"2016-09-27T05:55:18.822Z","comments":true,"path":"2016/06/08/font-spider/","link":"","permalink":"http://yfzhang.cn/2016/06/08/font-spider/","excerpt":"","text":"设计往往会提供一些自定义字体，而调用自定义字体往往会增加这种单页页面的负担，但是我们为了尽量还原设计图，可以考虑将压缩之后的字体文件嵌入的网页之中。 1.全局安装font-spider插件1$ npm install -g font-spider 2.在你需要加入字体的HTML页面上加入下列CSS12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*声明 WebFont*/ @font-face &#123; font-family: 'ouzhou'; src: url('./ouzhou.eot'); src: url('./ouzhou.eot?#font-spider') format('embedded-opentype'), url('./ouzhou.woff') format('woff'), url('./ouzhou.ttf') format('truetype'), url('./ouzhou.svg') format('svg'); font-weight: normal; font-style: normal; &#125; body&#123; font-family: 'ouzhou'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;123456789.:法国英国美国德国&lt;/body&gt;&lt;/html&gt; 其中的.ttf文件是必须存在的,body标签中的文字是font-spider用来转化的字体,未在body中出现的字符将会用浏览器默认的字体显示。 3.执行font-spider的指令1font-spider ./index.html(html的路径) 这时font-spider会在目录下生成： 浏览器上查看，字体文件成功应用: demo中使用自定义字体的字符仅有“123456789.:法国英国美国德国”这几个，所以字体文件都在5KB左右的大小。比较麻烦的是需要将H5中会使用到的字体都收集过来让font-spider解析并生成字体文件。","categories":[{"name":"css","slug":"css","permalink":"http://yfzhang.cn/categories/css/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yfzhang.cn/tags/CSS3/"}],"keywords":[{"name":"css","slug":"css","permalink":"http://yfzhang.cn/categories/css/"}]},{"title":"First Blood.","slug":"hello-world","date":"2016-06-01T09:41:58.000Z","updated":"2016-09-27T05:55:18.825Z","comments":true,"path":"2016/06/01/hello-world/","link":"","permalink":"http://yfzhang.cn/2016/06/01/hello-world/","excerpt":"","text":"之前在主机公园上使用免费的虚拟主机搭建了一个博客,由于速度太慢(服务器貌似在印度…)果断入坑hexo. 下面记录一下更新博文和重新部署的方式: Quick Start1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"web","slug":"web","permalink":"http://yfzhang.cn/categories/web/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://yfzhang.cn/tags/建站/"}],"keywords":[{"name":"web","slug":"web","permalink":"http://yfzhang.cn/categories/web/"}]}]}